//#include "functions.clu"
//#include "defines.clu"
DefVarsN3(); // Define CGA (G_{4,1})
DrawFrame(0.5,"axes"); // Reference frame


:IPNS;
EnableAnimate(CheckBox("Animate", 0));
if (ExecMode & !EM_ANIMATE) {
	Data = ReadData("data.dat");
    ?N = Size(Data);
}
?i = round(Time * ANIMATION_SPEED, 0) % N + 1; // +1 because of 1-based indexing
frame_data = Data(i);

global_motor = TranslatorN3(
							frame_data(ORIGIN_TRANSLATION + X),
							frame_data(ORIGIN_TRANSLATION + Y),
							frame_data(ORIGIN_TRANSLATION + Z)
							)
			* RotorN3(1, 0, 0, frame_data(ORIGIN_ROT + X))
			* RotorN3(0, 1, 0, frame_data(ORIGIN_ROT + Y))
			* RotorN3(0, 0, 1, frame_data(ORIGIN_ROT + Z));
M = global_motor;
O = M * e0 * (~M); // Start point (origin)


LegFromPelvis =
{
    pelvis_point = _P(1);
    is_right = _P(2); // boolean, put 1 if right, 0 otherwise
    global_motor = _P(3);
    frame_data = _P(4);

	// write a sphere - cylinder - sphere - cylinder - box
    X = 0;
    Y = 1;
    Z = 2;

	ZOOM = 0.4;

    // Define some constants
	FEMUR_LENGHT = 3.806 * ZOOM;
	TIBIAS_LENGHT = 3.586 * ZOOM;

	
	LEG_OFFSET_FROM_LEFT_TO_RIGHT = 7;
	PELVIS_ROT = 19;
	KNEE_ROT = 20;
	FOOT_ROT = 23;

	FOOT_LENGHT = 0.718 * ZOOM;
	FOOT_DIMENSIONS = [FOOT_LENGHT * 3.0, FOOT_LENGHT, FOOT_LENGHT * 5.0];
	// KNEE_SPACE_LENGHT = 2.079 * ZOOM;
	// FOOT_SPACE_LENGHT = 2.116 * ZOOM;

	if (is_right) {
		side = " right";
	} else {
		side = " left";
	}

	// Pelvis Rotation
	pelvis_x_rot = frame_data(PELVIS_ROT + (LEG_OFFSET_FROM_LEFT_TO_RIGHT * is_right) + X);
	pelvis_y_rot = frame_data(PELVIS_ROT + (LEG_OFFSET_FROM_LEFT_TO_RIGHT * is_right) + Y);
	pelvis_z_rot = frame_data(PELVIS_ROT + (LEG_OFFSET_FROM_LEFT_TO_RIGHT * is_right) + Z);

	pelvis_x_rot = Slider("Pelvis Rot. X" + side, -Pi, Pi, 0.1, 0);
	pelvis_y_rot = Slider("Pelvis Rot. Y" + side, -Pi, Pi, 0.1, 0);
	pelvis_z_rot = Slider("Pelvis Rot. Z" + side, -Pi, Pi, 0.1, 0);

	// Femur
	rotor_x = RotorN3(1, 0, 0, pelvis_x_rot);
	rotor_y = RotorN3(0, 1, 0, pelvis_y_rot);
	rotor_z = RotorN3(0, 0, 1, pelvis_z_rot);
	global_motor = global_motor * (rotor_x * rotor_y * rotor_z * TranslatorN3(0, -FEMUR_LENGHT, 0)); //auxiliary motor ("accumulated")
	knee_point = global_motor * e0 * (~global_motor);

	// Knee Rotation
	knee_x_rot = frame_data(KNEE_ROT + (LEG_OFFSET_FROM_LEFT_TO_RIGHT * is_right) + X);
	knee_y_rot = frame_data(KNEE_ROT + (LEG_OFFSET_FROM_LEFT_TO_RIGHT * is_right) + Y);
	knee_z_rot = frame_data(KNEE_ROT + (LEG_OFFSET_FROM_LEFT_TO_RIGHT * is_right) + Z);

	knee_x_rot = Slider("Knee Rot. X" + side, -Pi, Pi, 0.1, knee_x_rot);
	knee_y_rot = Slider("Knee Rot. Y" + side, -Pi, Pi, 0.1, knee_y_rot);
	knee_z_rot = Slider("Knee Rot. Z" + side, -Pi, Pi, 0.1, knee_z_rot);

	// Tibias
	rotor_x = RotorN3(1, 0, 0, knee_x_rot);
	rotor_y = RotorN3(0, 1, 0, knee_y_rot);
	rotor_z = RotorN3(0, 0, 1, knee_z_rot);
	global_motor = global_motor * (rotor_x * rotor_y * rotor_z * TranslatorN3(0, -TIBIAS_LENGHT, 0)); //auxiliary motor ("accumulated")
	foot_point = global_motor * e0 * (~global_motor);

	// Foot Rotation
	foot_x_rot = frame_data(FOOT_ROT + (LEG_OFFSET_FROM_LEFT_TO_RIGHT * is_right) + X);
	foot_y_rot = frame_data(FOOT_ROT + (LEG_OFFSET_FROM_LEFT_TO_RIGHT * is_right) + Y);
	foot_z_rot = frame_data(FOOT_ROT + (LEG_OFFSET_FROM_LEFT_TO_RIGHT * is_right) + Z);

	foot_x_rot = Slider("Foot Rot. X" + side, -Pi, Pi, 0.1, foot_x_rot);
	foot_y_rot = Slider("Foot Rot. Y" + side, -Pi, Pi, 0.1, foot_y_rot);
	foot_z_rot = Slider("Foot Rot. Z" + side, -Pi, Pi, 0.1, foot_z_rot);

	// Foot
	rotor_x = RotorN3(1, 0, 0, foot_x_rot);
	rotor_y = RotorN3(0, 1, 0, foot_y_rot);
	rotor_z = RotorN3(0, 0, 1, foot_z_rot);
	global_motor = global_motor * (rotor_x * rotor_y * rotor_z); //auxiliary motor ("accumulated")


	// Draw
	if (is_right) {
		:White;
	} else {
		:Blue;
	}
	:pelvis_point - 1/2 * (0.15)^^2 * einf; // Pelvis
	:knee_point - 1/2 * (0.15)^^2 * einf; // Knee
	::Box(foot_point, FOOT_DIMENSIONS, global_motor); // Foot
	
	if (is_right) {
		:Yellow;
	} else {
		:Magenta;
	}
	::Cylinder(pelvis_point, knee_point, 0.05); // Femur
	::Cylinder(knee_point, foot_point, 0.05); // Tibias
}

ArmFromSternum =
{
    starting_point = _P(1);
    is_left = _P(2); // boolean
    global_motor = _P(3);

	// write a sphere - cylinder - sphere - cylinder - box

    // Define some constants
    X = 1; // +1 because of 1-based indexing
    Y = 2;
    Z = 3;

}

leg_global_motor_r = TranslatorN3(-(PELVIS_V_LENGHT / 2), 0, 0);
leg_global_motor_l = TranslatorN3((PELVIS_V_LENGHT / 2), 0, 0);
leg_r_motor = global_motor * leg_global_motor_r;
leg_l_motor = global_motor * leg_global_motor_l;
::LegFromPelvis(leg_l_motor * e0 * (~leg_l_motor), false, leg_l_motor, frame_data); // left
::LegFromPelvis(leg_r_motor * e0 * (~leg_r_motor), true, leg_r_motor, frame_data); // right


//   | y
// /z -x

// e1 = x
// e2 = y
// e3 = z
