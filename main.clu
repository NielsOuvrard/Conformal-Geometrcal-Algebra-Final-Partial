//#include "functions.clu"
//#include "defines.clu"
DefVarsN3(); // Define CGA (G_{4,1})
DrawFrame(0.5,"axes"); // Reference frame


:IPNS;
EnableAnimate(CheckBox("Animate", 0));
if (ExecMode & !EM_ANIMATE) {
	Data = ReadData("datos.dat");
    ?N = Size(Data);
}
?i = round(Time * ANIMATION_SPEED, 0) % N + 1; // +1 because of 1-based indexing
frame_data = Data(i);

global_motor = TranslatorN3(frame_data(ORIGIN_TRANSLATION + iX), frame_data(ORIGIN_TRANSLATION + iY), frame_data(ORIGIN_TRANSLATION + iZ))
	 * RotorN3(1, 0, 0, frame_data(ORIGIN_ROT + iX)) * RotorN3(0, 1, 0, frame_data(ORIGIN_ROT + iY)) * RotorN3(0, 0, 1, frame_data(ORIGIN_ROT + iZ)); // Global Motor
M = global_motor;
O = M * e0 * (~M); // Start point (origin)


LegFromPelvis =
{
    top_point = _P(1);
    is_right = _P(2); // boolean, put 1 if right, 0 otherwise
    global_motor = _P(3);
    frame_data = _P(4);

	// write a sphere - cylinder - sphere - cylinder - box
    X = 0;
    Y = 1;
    Z = 2;

	ZOOM = 0.4;

    // Define some constants
	FEMUR_LENGHT = 3.806 * ZOOM;
	TIBIAS_LENGHT = 3.586 * ZOOM;

	
	INDEXES_FROM_LEFT_TO_RIGHT = 7;
	LEG_ROT = 19;
	KNEE_ROT = 20;
	FOOT_ROT = 23;

	FOOT_LENGHT = 0.718 * ZOOM;
	FOOT_DIMENSIONS = [FOOT_LENGHT * 3.0, FOOT_LENGHT, FOOT_LENGHT * 5.0];
	// KNEE_SPACE_LENGHT = 2.079 * ZOOM;
	// FOOT_SPACE_LENGHT = 2.116 * ZOOM;


	// Femur
	R1 = RotorN3(0, 0, 1, frame_data(LEG_ROT + (INDEXES_FROM_LEFT_TO_RIGHT * is_right) + Z));
	T1 = TranslatorN3(0, -FEMUR_LENGHT, 0);
	global_motor_1 = R1 * T1; // First motor
	global_motor = global_motor * global_motor_1; //auxiliary motor ("accumulated")
	P1 = global_motor * e0 * (~global_motor);

	// Tibias
	R2 = RotorN3(0, 0, 1, frame_data(KNEE_ROT + (INDEXES_FROM_LEFT_TO_RIGHT * is_right) + Z));
	T2 = TranslatorN3(0, -TIBIAS_LENGHT, 0);
	global_motor_2 = R2 * T2; // Second motor
	global_motor = global_motor * global_motor_2; //auxiliary motor ("accumulated")
	P2 = global_motor * e0 * (~global_motor);

	// Draw
	:White;
	:top_point - 1/2 * (0.15)^^2 * einf; // Femur-Top
	:P1 - 1/2 * (0.15)^^2 * einf; // Tibias-Top
	::Box(P2, FOOT_DIMENSIONS, global_motor); // Foot
	
	if (is_right) {
		:Yellow;
	} else {
		:Magenta;
	}
	::Cylinder(top_point, P1, 0.05); // Femur
	::Cylinder(P1, P2, 0.05); // Tibias
}

ArmFromSternum =
{
    starting_point = _P(1);
    is_left = _P(2); // boolean
    global_motor = _P(3);

	// write a sphere - cylinder - sphere - cylinder - box

    // Define some constants
    X = 1; // +1 because of 1-based indexing
    Y = 2;
    Z = 3;

}

leg_global_motor = TranslatorN3(PELVIS_V_LENGHT, 0, 0);
::LegFromPelvis(O * (leg_global_motor / 2), false, global_motor, frame_data); // left
::LegFromPelvis(O * -(leg_global_motor / 2), true, global_motor, frame_data); // right


//   | y
// /z -x

// e1 = x
// e2 = y
// e3 = z
