//#include "functions.clu"
//#include "defines.clu"
DefVarsN3(); // Define CGA (G_{4,1})
DrawFrame(0.5,"axes"); // Reference frame


:IPNS;
EnableAnimate(CheckBox("Animate", 0));
if (ExecMode & !EM_ANIMATE) {
	Data = ReadData("datos.dat");
    ?N = Size(Data);
}
?i = round(Time * ANIMATION_SPEED, 0) % N + 1; // +1 because of 1-based indexing
frame_data = Data(i);


Mg = TranslatorN3(frame_data(ORIGIN_TRANSLATION + iX), frame_data(ORIGIN_TRANSLATION + iY), frame_data(ORIGIN_TRANSLATION + iZ))
	 * RotorN3(1, 0, 0, frame_data(ORIGIN_ROT + iX)) * RotorN3(0, 1, 0, frame_data(ORIGIN_ROT + iY)) * RotorN3(0, 0, 1, frame_data(ORIGIN_ROT + iZ)); // Global Motor
M = Mg;
O = M * e0 * (~M); // Start point (origin)

R1 = RotorN3(0, 0, 1, frame_data(LEG_LEFT_ROT + iZ));
T1 = TranslatorN3(0, -FEMUR_LENGHT, 0);
M1 = R1 * T1; // First motor
fM = M * M1; //auxiliary motor ("accumulated")
P1 = fM * e0 * (~fM);


R2 = RotorN3(0, 0, 1, frame_data(LEG_RIGHT_ROT + iY));
T2 = TranslatorN3(0, -TIBIAS_LENGHT, 0);
M2 = R2 * T2; // Second motor
M = fM * M2; //auxiliary motor ("accumulated")
P2 = M * e0 * (~M);

:White;
:P1 - 1/2 * (0.15)^^2 * einf;
::Box(P2, [0.3, 0.1, 0.5], M);

:Yellow;
::Cylinder(O, P1, 0.05);
::Cylinder(P1, P2, 0.05);
