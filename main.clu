//#include "functions.clu"
//#include "defines.clu"
DefVarsN3(); // Define CGA (G_{4,1})
DrawFrame(0.5,"axes"); // Reference frame


:IPNS;
EnableAnimate(CheckBox("Animate", 0));
if (ExecMode & !EM_ANIMATE) {
	Data = ReadData("datos.dat");
    ?N = Size(Data);
}
?i = round(Time * ANIMATION_SPEED, 0) % N + 1; // +1 because of 1-based indexing
frame_data = Data(i);

global_motor = TranslatorN3(frame_data(ORIGIN_TRANSLATION + iX), frame_data(ORIGIN_TRANSLATION + iY), frame_data(ORIGIN_TRANSLATION + iZ))
	 * RotorN3(1, 0, 0, frame_data(ORIGIN_ROT + iX)) * RotorN3(0, 1, 0, frame_data(ORIGIN_ROT + iY)) * RotorN3(0, 0, 1, frame_data(ORIGIN_ROT + iZ)); // Global Motor
M = global_motor;
O = M * e0 * (~M); // Start point (origin)


LegFromPelvis =
{
    top_point = _P(1);
    is_left = _P(2); // boolean
    global_motor = _P(3);
    frame_data = _P(4);

	// write a sphere - cylinder - sphere - cylinder - box
	ZOOM = 0.4;

    // Define some constants
	FEMUR_LENGHT = 3.806 * ZOOM;
	// KNEE_SPACE_LENGHT = 2.079 * ZOOM;
	TIBIAS_LENGHT = 3.586 * ZOOM;
	// FOOT_SPACE_LENGHT = 2.116 * ZOOM;
	FOOT_LENGHT = 0.718 * ZOOM;

	FOOT_DIMENSIONS = [FOOT_LENGHT * 3.0, FOOT_LENGHT, FOOT_LENGHT * 5.0];
	

	// HJLxr HJLyr HJLzr // Leg Left
	LEG_LEFT_ROT = 22;
	// KJLxr
	KNEE_LEFT_ROT = 25;
	// AJLxr AJLyr AJLzr
	FOOT_LEFT_ROT = 26;

	// HJRxr HJRyr HJRzr // Leg Right
	LEG_RIGHT_ROT = 29;
	// KJRxr
	KNEE_RIGHT_ROT = 30;
	// AJRxr AJRyr AJRzr 
	FOOT_RIGHT_ROT = 33;

    X = 1; // +1 because of 1-based indexing
    Y = 2;
    Z = 3;

	// Femur
	R1 = RotorN3(0, 0, 1, frame_data(LEG_LEFT_ROT + Z));
	T1 = TranslatorN3(0, -FEMUR_LENGHT, 0);
	global_motor_1 = R1 * T1; // First motor
	global_motor = global_motor * global_motor_1; //auxiliary motor ("accumulated")
	P1 = global_motor * e0 * (~global_motor);

	// Tibias
	R2 = RotorN3(0, 0, 1, frame_data(LEG_RIGHT_ROT + Y));
	T2 = TranslatorN3(0, -TIBIAS_LENGHT, 0);
	global_motor_2 = R2 * T2; // Second motor
	global_motor = global_motor * global_motor_2; //auxiliary motor ("accumulated")
	P2 = global_motor * e0 * (~global_motor);

	// Draw
	:White;
	:top_point - 1/2 * (0.15)^^2 * einf; // Femur-Top
	:P1 - 1/2 * (0.15)^^2 * einf; // Tibias-Top
	::Box(P2, FOOT_DIMENSIONS, global_motor); // Foot

	:Yellow;
	::Cylinder(top_point, P1, 0.05); // Femur
	::Cylinder(P1, P2, 0.05); // Tibias
}

ArmFromSternum =
{
    starting_point = _P(1);
    is_left = _P(2); // boolean
    global_motor = _P(3);

	// write a sphere - cylinder - sphere - cylinder - box

    // Define some constants
    X = 1; // +1 because of 1-based indexing
    Y = 2;
    Z = 3;

}

::LegFromPelvis(O, false, global_motor, frame_data);

